# ADR-0008: Prefetching de imagens ao hover no CardProfissional

## Vinculado a
TASK-0014 (Quick Win: MPF-006 - Prefetching ao hover)

## Status
Accepted

## Contexto

O site do Instituto Jardim apresentava uma experiência de navegação com delay perceptível ao clicar em um card de profissional. A imagem do profissional era carregada apenas no momento da transição para a página de detalhes, causando um "flash" ou delay visual enquanto o recurso era baixado.

Com a otimização de SVGs realizada na TASK-0011, as imagens ficaram menores (mas o denis-graciotto.svg ainda possui 5.3 MB devido ao JPEG embedado), tornando o prefetching ainda mais viável e eficaz.

**Problema**: Como melhorar a percepção de velocidade na navegação entre cards e páginas de profissionais?

**Alternativas consideradas**:
1. Carregar todas as imagens de forma eager no carregamento inicial
2. Usar `<link rel="prefetch">` no HTML
3. Implementar prefetching ao hover com debounce
4. Usar Service Worker para cache agressivo

## Decisão

Implementamos prefetching de imagem ao hover no componente `CardProfissional.tsx` com as seguintes características:

### Abordagem escolhida: Prefetching ao hover com debounce de 300ms

**Implementação**:
- Ao evento `onMouseEnter`, iniciar timer de 300ms
- Após 300ms, criar `new Image()` e atribuir `img.src = profissional.foto`
- No evento `onMouseLeave`, cancelar timer (se hover < 300ms)
- Usar `useRef<Set<string>>` para evitar prefetches duplicados da mesma imagem
- Cleanup de timeouts no `useEffect` para evitar memory leaks

**Código**:
```typescript
const prefetchedRef = useRef<Set<string>>(new Set());
const timerRef = useRef<number | null>(null);

useEffect(() => {
  return () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  };
}, []);

const handleMouseEnter = () => {
  if (prefetchedRef.current.has(profissional.foto)) return;

  timerRef.current = setTimeout(() => {
    const img = new Image();
    img.src = profissional.foto;
    prefetchedRef.current.add(profissional.foto);
  }, 300);
};

const handleMouseLeave = () => {
  if (timerRef.current) {
    clearTimeout(timerRef.current);
    timerRef.current = null;
  }
};
```

### Por que 300ms de debounce?

Estudos de UX mostram que 300ms é um bom equilíbrio:
- Curto o suficiente para capturar intenção real de clique (hover acidental < 300ms)
- Longo o suficiente para evitar prefetches desnecessários em hovers rápidos
- Tempo médio de hover antes do click é ~500ms, então 300ms dá margem para prefetch completar

## Consequências

### Positivas

1. **Percepção de velocidade melhorada**: Navegação entre card e página de detalhes é instantânea (imagem já em cache)
2. **Sem overhead inicial**: Não carrega recursos desnecessários no load inicial (diferente de eager loading)
3. **Uso eficiente de banda**: Debounce de 300ms evita downloads desnecessários em hovers acidentais
4. **Sem prefetches duplicados**: Set mantém histórico de URLs já prefetchados
5. **Sem memory leaks**: Cleanup correto de timeouts no unmount
6. **Compatível com cache HTTP**: Se imagem já estiver em cache, prefetch é no-op
7. **Funciona em conjunto com lazy loading**: A tag `<img loading="lazy">` continua funcionando normalmente
8. **Melhoria sutil**: Não altera comportamento funcional existente, apenas otimiza

### Negativas

1. **Uso de banda adicional**: Usuários que passam o mouse mas não clicam irão baixar imagens desnecessariamente (mitigado pelo debounce)
2. **Limitado a desktop/mouse**: Dispositivos touch não disparam `onMouseEnter` (mas não causa problemas, apenas não obtém benefício)
3. **Pequeno overhead de memória**: Set de URLs prefetchados permanece em memória (mas é mínimo, ~3 URLs)
4. **Não funciona offline**: Prefetch requer conexão (mas é caso de uso raro)

### Trade-offs aceitos

- **Banda vs UX**: Aceito gasto moderado de banda (prefetch em hovers > 300ms) em troca de navegação instantânea
- **Complexidade vs benefício**: Adiciona ~30 linhas de código, mas melhoria de UX é significativa
- **Mobile vs Desktop**: Prefetch só funciona em desktop, mas não degrada experiência mobile

## Alternativas Consideradas

### Alternativa 1: Eager loading de todas as imagens
- **Descrição**: Remover `loading="lazy"` e carregar todas as imagens no load inicial
- **Prós**: Navegação sempre instantânea, sem lógica adicional
- **Contras**: Aumenta significativamente tempo de carregamento inicial (~6 MB de imagens), desperdício de banda se usuário não navegar para todos os profissionais
- **Motivo da rejeição**: Piora a métrica Core Web Vitals (LCP), vai contra best practices de performance

### Alternativa 2: `<link rel="prefetch">` no HTML
- **Descrição**: Adicionar tags `<link rel="prefetch" href="/imagens/profissionais/...">` no `<head>`
- **Prós**: Navegador gerencia prioridade automaticamente, sintaxe nativa
- **Contras**: Prefetch é low-priority, pode não completar antes do clique, não há controle fino (debounce, hover detection)
- **Motivo da rejeição**: Menos controle sobre quando/como prefetch ocorre, prioridade muito baixa

### Alternativa 3: Service Worker com cache estratégico
- **Descrição**: Implementar Service Worker para cache agressivo com estratégia stale-while-revalidate
- **Prós**: Cache persistente entre navegações, funciona offline
- **Contras**: Complexidade significativa, requer registro de Service Worker, debugging mais difícil, overkill para 3 profissionais
- **Motivo da rejeição**: Over-engineering para o problema atual, complexidade desproporcional ao benefício

### Alternativa 4: Preconnect ou DNS-prefetch
- **Descrição**: Usar `<link rel="preconnect">` ou `<link rel="dns-prefetch">`
- **Prós**: Reduz latência de conexão
- **Contras**: Imagens estão no mesmo domínio, não há ganho real
- **Motivo da rejeição**: Não aplicável, recursos são same-origin

## Validação

Para verificar que a implementação funciona:

1. Abrir DevTools -> Network tab
2. Passar mouse sobre um card e manter por > 300ms
3. Verificar que request da imagem aparece na Network tab
4. Clicar no card
5. Verificar que imagem não é baixada novamente (status 304 ou from cache)
6. Passar mouse rapidamente (< 300ms) e verificar que prefetch NÃO ocorre

**Resultado esperado**: Navegação instantânea, imagem já em cache ao clicar.

## Notas de Implementação

- **TypeScript**: Usar `number` em vez de `NodeJS.Timeout` para compatibilidade com ambiente browser
- **Cleanup**: Essencial limpar timeout no `useEffect` cleanup para evitar memory leaks
- **Set vs Map**: Set é suficiente, não precisamos armazenar metadados além da URL
- **Ref vs State**: useRef é correto aqui, não queremos re-render ao adicionar URL no Set
- **Compatibilidade**: `new Image()` é suportado por todos os browsers modernos

## Referências

- [MDN: Preloading content with rel="preload"](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/preload)
- [web.dev: Prefetch resources](https://web.dev/articles/link-prefetch)
- [React: useRef Hook](https://react.dev/reference/react/useRef)
- [UX Research: Hover intent detection](https://www.nngroup.com/articles/timing-exposing-content/)
